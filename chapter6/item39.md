> **명명 패턴?**
> 
> 
> 변수나 함수의 이름을 일관된 방식으로 작성하는 패턴.
> 

**ex )  JUnit3 에서는 테스트 메서드 이름을 test 로 시작하게끔 했다. 이러한 명명 패턴 방식은 효과적이지만 단점도 크다.** 

**명명 패턴의 단점.** 

- 오타가 나면 안 된다.
- 명명 패턴을 의도한 곳에서만 사용할 거라는 보장이 없다.
- 명명 패턴을 적용한 요소를 매개변수로 전달할 마땅한 방법이 없다.

**위와 같은 단점을 모두 해결할 수 있는 방법이 있는데, 애너테이션을 사용하는 것이다.** 

> **[애너테이션이란?](https://eatnows.tistory.com/92)
프로그램의 소스 코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션이다.**
> 

[애너테이션이란?](https://eatnows.tistory.com/92)

```java
/**
* 테스트 메서드임을 선언하는 애너테이션이다.
* 매개변수 없는 정적 메서드 전용
*/
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test{}
```

**메타 애너테이션**

- @Retention(RetentionPolicy.RUNTIME)  - 보존 정책.
    - @Test 가 런타임에도 유지되어야 한다는 표시
- @Target(ElementType.METHOD) - 적용 대상.
    - @Test가 반드시 메서드에 선언되어야 한다는 표시.

**실제 클래스가 동작하는데 직접적인 영향을 미치는 게 아니고 유용한 정보를 제공할 뿐이다.**

---

**반복가능한 애너테이션**

: Java8부터는 단일 요소에 애너테이션을 반복적으로 달 수 있는 @Repeatable 매타 애너테이션을 제공한다. 

따라서 배열 매개변수 대신 @Repeatable 매타 애너테이션을 달면 단일 요소에 반복적으로 적용할 수 있게 되었다. 

**@Repeatable 사용 시 주의점**

**1. @Repeatable을 명시한 애너테이션을 반환하는 컨테이너 애너테이션을 하나 더 정의해야 한다. 그리고 @Repeatable에 해당 컨테이너 애너테이션의 class 객체를 매개변수로 전달해야 한다.**

**2. 컨테이너 애너테이션은 내부 애너테이션 타입의 배열을 반환하는 value 메서드를 정의해야 한다.**

**3. 적절한 @Retention과 @Target을 명시해야 한다. 그렇지 않으면 컴파일되지 않는다.**

---

**정리** 

**애너테이션으로 처리할 수 있다면 명명 패턴을 사용할 이유는 없다.** 

**어떤 도구 제작자를 제외하고 애너테이션 타입을 직접 정의할 일은 거의 없다. 하지만 자바 프로그래머라면 예외 없이 자바가 제공하는 애너테이션 타입들은 사용하자.**

[어노테이션](https://velog.io/@kwj1270/%EC%96%B4%EB%85%B8%ED%85%8C%EC%9D%B4%EC%85%98)